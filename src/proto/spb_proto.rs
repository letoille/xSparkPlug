// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Payload {
    /// Timestamp at message sending time
    #[prost(uint64, optional, tag = "1")]
    pub timestamp: ::core::option::Option<u64>,
    /// Repeated forever - no limit in Google Protobufs
    #[prost(message, repeated, tag = "2")]
    pub metrics: ::prost::alloc::vec::Vec<payload::Metric>,
    /// Sequence number
    #[prost(uint64, optional, tag = "3")]
    pub seq: ::core::option::Option<u64>,
    /// UUID to track message type in terms of schema definitions
    #[prost(string, optional, tag = "4")]
    pub uuid: ::core::option::Option<::prost::alloc::string::String>,
    /// To optionally bypass the whole definition above
    #[prost(bytes = "vec", optional, tag = "5")]
    pub body: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `Payload`.
pub mod payload {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Template {
        /// The version of the Template to prevent mismatches
        #[prost(string, optional, tag = "1")]
        pub version: ::core::option::Option<::prost::alloc::string::String>,
        /// Each metric includes a name, datatype, and optionally a value
        #[prost(message, repeated, tag = "2")]
        pub metrics: ::prost::alloc::vec::Vec<Metric>,
        #[prost(message, repeated, tag = "3")]
        pub parameters: ::prost::alloc::vec::Vec<template::Parameter>,
        /// MUST be a reference to a template definition if this is an instance (i.e. the name of the template definition) - MUST be omitted for template definitions
        #[prost(string, optional, tag = "4")]
        pub template_ref: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bool, optional, tag = "5")]
        pub is_definition: ::core::option::Option<bool>,
    }
    /// Nested message and enum types in `Template`.
    pub mod template {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Parameter {
            #[prost(string, optional, tag = "1")]
            pub name: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(uint32, optional, tag = "2")]
            pub r#type: ::core::option::Option<u32>,
            #[prost(oneof = "parameter::Value", tags = "3, 4, 5, 6, 7, 8, 9")]
            pub value: ::core::option::Option<parameter::Value>,
        }
        /// Nested message and enum types in `Parameter`.
        pub mod parameter {
            #[derive(Clone, Copy, PartialEq, ::prost::Message)]
            pub struct ParameterValueExtension {}
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Value {
                #[prost(uint32, tag = "3")]
                IntValue(u32),
                #[prost(uint64, tag = "4")]
                LongValue(u64),
                #[prost(float, tag = "5")]
                FloatValue(f32),
                #[prost(double, tag = "6")]
                DoubleValue(f64),
                #[prost(bool, tag = "7")]
                BooleanValue(bool),
                #[prost(string, tag = "8")]
                StringValue(::prost::alloc::string::String),
                #[prost(message, tag = "9")]
                ExtensionValue(ParameterValueExtension),
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DataSet {
        #[prost(uint64, optional, tag = "1")]
        pub num_of_columns: ::core::option::Option<u64>,
        #[prost(string, repeated, tag = "2")]
        pub columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(uint32, repeated, packed = "false", tag = "3")]
        pub types: ::prost::alloc::vec::Vec<u32>,
        #[prost(message, repeated, tag = "4")]
        pub rows: ::prost::alloc::vec::Vec<data_set::Row>,
    }
    /// Nested message and enum types in `DataSet`.
    pub mod data_set {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct DataSetValue {
            #[prost(oneof = "data_set_value::Value", tags = "1, 2, 3, 4, 5, 6, 7")]
            pub value: ::core::option::Option<data_set_value::Value>,
        }
        /// Nested message and enum types in `DataSetValue`.
        pub mod data_set_value {
            #[derive(Clone, Copy, PartialEq, ::prost::Message)]
            pub struct DataSetValueExtension {}
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Value {
                #[prost(uint32, tag = "1")]
                IntValue(u32),
                #[prost(uint64, tag = "2")]
                LongValue(u64),
                #[prost(float, tag = "3")]
                FloatValue(f32),
                #[prost(double, tag = "4")]
                DoubleValue(f64),
                #[prost(bool, tag = "5")]
                BooleanValue(bool),
                #[prost(string, tag = "6")]
                StringValue(::prost::alloc::string::String),
                #[prost(message, tag = "7")]
                ExtensionValue(DataSetValueExtension),
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Row {
            #[prost(message, repeated, tag = "1")]
            pub elements: ::prost::alloc::vec::Vec<DataSetValue>,
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PropertyValue {
        #[prost(uint32, optional, tag = "1")]
        pub r#type: ::core::option::Option<u32>,
        #[prost(bool, optional, tag = "2")]
        pub is_null: ::core::option::Option<bool>,
        #[prost(oneof = "property_value::Value", tags = "3, 4, 5, 6, 7, 8, 9, 10, 11")]
        pub value: ::core::option::Option<property_value::Value>,
    }
    /// Nested message and enum types in `PropertyValue`.
    pub mod property_value {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct PropertyValueExtension {}
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Value {
            #[prost(uint32, tag = "3")]
            IntValue(u32),
            #[prost(uint64, tag = "4")]
            LongValue(u64),
            #[prost(float, tag = "5")]
            FloatValue(f32),
            #[prost(double, tag = "6")]
            DoubleValue(f64),
            #[prost(bool, tag = "7")]
            BooleanValue(bool),
            #[prost(string, tag = "8")]
            StringValue(::prost::alloc::string::String),
            #[prost(message, tag = "9")]
            PropertysetValue(super::PropertySet),
            /// List of Property Values
            #[prost(message, tag = "10")]
            PropertysetsValue(super::PropertySetList),
            #[prost(message, tag = "11")]
            ExtensionValue(PropertyValueExtension),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PropertySet {
        /// Names of the properties
        #[prost(string, repeated, tag = "1")]
        pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(message, repeated, tag = "2")]
        pub values: ::prost::alloc::vec::Vec<PropertyValue>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PropertySetList {
        #[prost(message, repeated, tag = "1")]
        pub propertyset: ::prost::alloc::vec::Vec<PropertySet>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MetaData {
        /// Bytes specific metadata
        #[prost(bool, optional, tag = "1")]
        pub is_multi_part: ::core::option::Option<bool>,
        /// General metadata
        ///
        /// Content/Media type
        #[prost(string, optional, tag = "2")]
        pub content_type: ::core::option::Option<::prost::alloc::string::String>,
        /// File size, String size, Multi-part size, etc
        #[prost(uint64, optional, tag = "3")]
        pub size: ::core::option::Option<u64>,
        /// Sequence number for multi-part messages
        #[prost(uint64, optional, tag = "4")]
        pub seq: ::core::option::Option<u64>,
        /// File metadata
        ///
        /// File name
        #[prost(string, optional, tag = "5")]
        pub file_name: ::core::option::Option<::prost::alloc::string::String>,
        /// File type (i.e. xml, json, txt, cpp, etc)
        #[prost(string, optional, tag = "6")]
        pub file_type: ::core::option::Option<::prost::alloc::string::String>,
        /// md5 of data
        #[prost(string, optional, tag = "7")]
        pub md5: ::core::option::Option<::prost::alloc::string::String>,
        /// Catchalls and future expansion
        ///
        /// Could be anything such as json or xml of custom properties
        #[prost(string, optional, tag = "8")]
        pub description: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Metric {
        /// Metric name - should only be included on birth
        #[prost(string, optional, tag = "1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        /// Metric alias - tied to name on birth and included in all later DATA messages
        #[prost(uint64, optional, tag = "2")]
        pub alias: ::core::option::Option<u64>,
        /// Timestamp associated with data acquisition time
        #[prost(uint64, optional, tag = "3")]
        pub timestamp: ::core::option::Option<u64>,
        /// DataType of the metric/tag value
        #[prost(uint32, optional, tag = "4")]
        pub datatype: ::core::option::Option<u32>,
        /// If this is historical data and should not update real time tag
        #[prost(bool, optional, tag = "5")]
        pub is_historical: ::core::option::Option<bool>,
        /// Tells consuming clients such as MQTT Engine to not store this as a tag
        #[prost(bool, optional, tag = "6")]
        pub is_transient: ::core::option::Option<bool>,
        /// If this is null - explicitly say so rather than using -1, false, etc for some datatypes.
        #[prost(bool, optional, tag = "7")]
        pub is_null: ::core::option::Option<bool>,
        /// Metadata for the payload
        #[prost(message, optional, tag = "8")]
        pub metadata: ::core::option::Option<MetaData>,
        #[prost(message, optional, tag = "9")]
        pub properties: ::core::option::Option<PropertySet>,
        #[prost(
            oneof = "metric::Value",
            tags = "10, 11, 12, 13, 14, 15, 16, 17, 18, 19"
        )]
        pub value: ::core::option::Option<metric::Value>,
    }
    /// Nested message and enum types in `Metric`.
    pub mod metric {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct MetricValueExtension {}
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Value {
            #[prost(uint32, tag = "10")]
            IntValue(u32),
            #[prost(uint64, tag = "11")]
            LongValue(u64),
            #[prost(float, tag = "12")]
            FloatValue(f32),
            #[prost(double, tag = "13")]
            DoubleValue(f64),
            #[prost(bool, tag = "14")]
            BooleanValue(bool),
            #[prost(string, tag = "15")]
            StringValue(::prost::alloc::string::String),
            /// Bytes, File
            #[prost(bytes, tag = "16")]
            BytesValue(::prost::alloc::vec::Vec<u8>),
            #[prost(message, tag = "17")]
            DatasetValue(super::DataSet),
            #[prost(message, tag = "18")]
            TemplateValue(super::Template),
            #[prost(message, tag = "19")]
            ExtensionValue(MetricValueExtension),
        }
    }
}
/// Indexes of Data Types
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataType {
    /// Unknown placeholder for future expansion.
    Unknown = 0,
    /// Basic Types
    Int8 = 1,
    Int16 = 2,
    Int32 = 3,
    Int64 = 4,
    UInt8 = 5,
    UInt16 = 6,
    UInt32 = 7,
    UInt64 = 8,
    Float = 9,
    Double = 10,
    Boolean = 11,
    String = 12,
    DateTime = 13,
    Text = 14,
    /// Additional Metric Types
    Uuid = 15,
    DataSet = 16,
    Bytes = 17,
    File = 18,
    Template = 19,
    /// Additional PropertyValue Types
    PropertySet = 20,
    PropertySetList = 21,
    /// Array Types
    Int8Array = 22,
    Int16Array = 23,
    Int32Array = 24,
    Int64Array = 25,
    UInt8Array = 26,
    UInt16Array = 27,
    UInt32Array = 28,
    UInt64Array = 29,
    FloatArray = 30,
    DoubleArray = 31,
    BooleanArray = 32,
    StringArray = 33,
    DateTimeArray = 34,
}
impl DataType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "Unknown",
            Self::Int8 => "Int8",
            Self::Int16 => "Int16",
            Self::Int32 => "Int32",
            Self::Int64 => "Int64",
            Self::UInt8 => "UInt8",
            Self::UInt16 => "UInt16",
            Self::UInt32 => "UInt32",
            Self::UInt64 => "UInt64",
            Self::Float => "Float",
            Self::Double => "Double",
            Self::Boolean => "Boolean",
            Self::String => "String",
            Self::DateTime => "DateTime",
            Self::Text => "Text",
            Self::Uuid => "UUID",
            Self::DataSet => "DataSet",
            Self::Bytes => "Bytes",
            Self::File => "File",
            Self::Template => "Template",
            Self::PropertySet => "PropertySet",
            Self::PropertySetList => "PropertySetList",
            Self::Int8Array => "Int8Array",
            Self::Int16Array => "Int16Array",
            Self::Int32Array => "Int32Array",
            Self::Int64Array => "Int64Array",
            Self::UInt8Array => "UInt8Array",
            Self::UInt16Array => "UInt16Array",
            Self::UInt32Array => "UInt32Array",
            Self::UInt64Array => "UInt64Array",
            Self::FloatArray => "FloatArray",
            Self::DoubleArray => "DoubleArray",
            Self::BooleanArray => "BooleanArray",
            Self::StringArray => "StringArray",
            Self::DateTimeArray => "DateTimeArray",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Unknown" => Some(Self::Unknown),
            "Int8" => Some(Self::Int8),
            "Int16" => Some(Self::Int16),
            "Int32" => Some(Self::Int32),
            "Int64" => Some(Self::Int64),
            "UInt8" => Some(Self::UInt8),
            "UInt16" => Some(Self::UInt16),
            "UInt32" => Some(Self::UInt32),
            "UInt64" => Some(Self::UInt64),
            "Float" => Some(Self::Float),
            "Double" => Some(Self::Double),
            "Boolean" => Some(Self::Boolean),
            "String" => Some(Self::String),
            "DateTime" => Some(Self::DateTime),
            "Text" => Some(Self::Text),
            "UUID" => Some(Self::Uuid),
            "DataSet" => Some(Self::DataSet),
            "Bytes" => Some(Self::Bytes),
            "File" => Some(Self::File),
            "Template" => Some(Self::Template),
            "PropertySet" => Some(Self::PropertySet),
            "PropertySetList" => Some(Self::PropertySetList),
            "Int8Array" => Some(Self::Int8Array),
            "Int16Array" => Some(Self::Int16Array),
            "Int32Array" => Some(Self::Int32Array),
            "Int64Array" => Some(Self::Int64Array),
            "UInt8Array" => Some(Self::UInt8Array),
            "UInt16Array" => Some(Self::UInt16Array),
            "UInt32Array" => Some(Self::UInt32Array),
            "UInt64Array" => Some(Self::UInt64Array),
            "FloatArray" => Some(Self::FloatArray),
            "DoubleArray" => Some(Self::DoubleArray),
            "BooleanArray" => Some(Self::BooleanArray),
            "StringArray" => Some(Self::StringArray),
            "DateTimeArray" => Some(Self::DateTimeArray),
            _ => None,
        }
    }
}
